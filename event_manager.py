import pygame

class EventManager():
    """Allows objects within game to communicate with one another, whilst 
    remaining primarily decoupled. i.e Acts as interaction mediator, 
    whilst remaining heavily decoupled. Weak references are used to allow 
    Python to garbage collect listeners that are no longer existent within 
    the game, even if they haven't unregistered with the Event Manager. """

    def __init__(self):
        """Initialise Event Manager and setup the weak reference 
        dictionary. Create an empty array for the event queue and set the 
        current event, and score values to their defaults."""
        # Import the dictionary class from the weakref
        from weakref import WeakKeyDictionary
        # Create the dictionary for the subscribers
        self.listeners = WeakKeyDictionary()
        # Initialise class properties
        self.eventQueue = []
        self.currentEvent = None
        self.score = 0

        # Below initialises the rapid counter material
        self.rapidCounterName = ''
        self.rapidCounterValue = 0
        self.rapidCounterIncrementLevel = 1

    def register_listener(self, listener):
        """Allows classes to subscribe to Event Manager when events are posted. N.B. All subscribers are passed all events. Event types can be used if the game is required to scale."""
        self.listeners[listener] = 1

    def unregister_listener(self, listener):
        """Allows classes registered as subscribers to remove
        themselves from the Event Manager."""
        if listener in self.listeners.keys():
            del self.listeners[listeners]

    def post(self, event):
        """Allows classes to post events to the Event Manager and
        consequently expect them to be distributed to the other 
        Event Manager subscribers"""
        # Send the event to the Event Manager's Rapid Counter method to check
        # if the counter's need incrementing
        self._rapid_counter_update(event)

        # If the event is in the list of events to be ignored, return 0 and 
        # terminate the response 
        if (event == ["CHARACTER_COLLIDE_COIN"] or
            event == ["CHARACTER_COLLIDE_INVIS"] or
            event == ["CHARACTER_COLLIDE_CLOUD"] or
            event == ["CHARACTER_COLLIDE_DRAGONFLY"]):
            return 0

        # If there currently isn't an event being dealt with by the Event 
        # manager, then set the latest event and notify all the classes 
        # currently subscribing. If there is currently an event being dealt 
        # with, ignore this event. If the game is required to scale, the event
        # queue can be used. Using this method, prevents duplicate events 
        # being generated by controllers etc.
        if self.currentEvent == None:
            self.currentEvent = event
            for listener in self.listeners.keys():
                listener.notify_event(event)

    def create_game_rapid_counter(self, rapidCounterName, incrementLevel):
        """Initialises a rapid counter on the event manager. 
        This can be used to manager a counter, such as health, time or scores 
        etc. Unlike the standard Event Manager this counter does acknowledge 
        duplicate events and as such has corresponding property differences."""
        # Initialises details
        self.rapidCounterName = rapidCounterName
        self.rapidCounterValue = 0
        self.rapidCounterIncrementLevel = incrementLevel
        
    def _rapid_counter_update(self, event):
        """Increments the counter if the current event 
        corresponds to the counter's rapid counter initialisation properties."""
        if event[0] == self.rapidCounterName:
            self.rapidCounterValue += self.rapidCounterIncrementLevel

    def get_rapid_counter_value(self, event):
        """This method returns the current value of the Rapid Counter."""
        return self.rapidCounterValue

    def event_clear(self, event):
        """Empties the current array when the previous action's 
        associated method has finished calling, thus preventing the event 
        Manager from blocking the game up"""
        if self.currentEvent == event:
            self.currentEvent = None
